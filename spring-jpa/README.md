# 📖 실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발

### 💻 Study Log

|날짜|학습 내용|완료 여부|학습 시간|
|:----:|----|:----:|:----:|
|2025.04.12.|Section 8. 웹 계층 개발 - 화면 구현, 컨트롤러 개발, 변경 감지와 병합 학습|✅|3시간|
|2025.04.05.|Section 7. 주문 도메인 개발 - 엔티티, 리포지토리, 서비스 개발 및 테스트|✅|2시간|
|2025.03.31.|Section 6. 상품 도메인 개발 - 엔티티(비즈니스 로직 추가), 리포지토리, 서비스 개발|✅|2시간|
|2025.03.29.|Section 5. 회원 도메인 개발 - 리포지토리, 서비스 개발, 테스트|✅|1시간|
|2025.03.28.|Section 3, 4. 도메인 분석 설계 - 요구사항 분석, 도메인 모델 및 테이블 설계, 엔티티 클래스 개발|✅|2시간|
|2025.03.27.|Section 1, 2. 프로젝트 환경설정 - 프로젝트 생성, 라이브러리, Thymleaf, H2 DB, JPA 및 DB 설정|✅|2시간|

### 🖥️ 실행 화면

|메인 페이지|
|:---:|
|<img src="./readme_asset/메인페이지.PNG" width="50%">|

|회원 가입|회원 목록|
|:---:|:---:|
|<img src="./readme_asset/회원 가입.PNG" width="50%">|<img src="./readme_asset/회원 목록.PNG" width="50%">|

|상품 등록|상품 목록|
|:---:|:---:|
|<img src="./readme_asset/상품 등록.PNG" width="50%">|<img src="./readme_asset/상품 목록.PNG" width="50%">|

|상품 주문|주문 내역|
|:---:|:---:|
|<img src="./readme_asset/상품 주문.PNG" width="50%">|<img src="./readme_asset/주문 내역.PNG" width="50%">|

### 💡 알게된 것

##### Section 6. 상품 도메인 개발
- Entity 자체에서 로직을 해결할 수 있는 경우, Entity 안에 비즈니스 로직을 작성
    - 객체지향적인 개발 (DDD)
    - 응집도가 높음
    - 데이터를 가지고 있는 쪽에 비즈니스 로직이 있는 것이 관리하기 좋음
- stockQuantity를 변경해야 할 경우
    - setStockQuantity() (setter) 으로 바깥에서 계산 X
    - 핵심 비즈니스 메서드를 가지고 변경

##### Section 7. 주문 도메인 개발
- 생성 메서드가 있는 경우
    - 기본 생성자를 protected로 제한하여 기본 생성자를 통한 생성을 방지
    - `@NoArgsConstructor(access = AccessLevel.*PROTECTED*)` 로 대체 가능

- DB를 직접 다루는 라이브러리 (ex. MyBatis 등)의 경우 데이터 변경 후 update 쿼리를 직접 작성하여 날려야 한다.
    - 로직을 바꾸고 데이터를 다 끄집어내서 파라미터를 넣어주고 쿼리를 작성해야 함
    - 하지만 JPA의 경우 엔티티의 데이터만 바꿔주면 dirty checking을 통해서 변경된 부분을 JPA가 알아서 update 쿼리를 날려줌
- 도메인 모델 패턴
    - 엔티티가 비즈니스 로직을 가지고 객체 지향의 특성을 활용하는 것
    - ↔️ 서비스 계층에 비즈니스 로직이 있는 패턴을 트랜잭션 스트립트 패턴이라고 한다.
    - 장점
        - 엔티티에서 핵심적인 비즈니스 로직이 만들어지므로, DB와 관계 없이 단위 테스트로 메서드에 대해서만 테스트 가능

- QueryDSL 쓰는 이유
    - 기존의 JPQL 이용 시 문자열 처리가 너무 복잡함
    - JPA 표준 스펙인 JPA Criteria 유지보수성이 떨어짐 코드는 간결해졌지만 마찬가지로 복잡

##### Section 8. 웹 계층 개발

- Entity를 최대한 순수하게 유지
    - 애플리케이션이 커져서 엔티티를 여러 곳에서 사용하더라도 유지보수성이 높아짐
    - 핵심 로직에만 dependency가 있도록 설정하는 것이 중요
    - 화면에 관한 API 등은 Form 객체나 DTO 객체를 사용
    - 화면에 뿌릴 때도, 엔티티를 뿌리기 보다 DTO를 사용해서 화면에 필요한 데이터만 뿌리는 것을 권장 
    - API를 만들 때에는 절대 엔티티를 웹으로 반환하면(넘기면) 안 됨
    - 엔티티에 로직을 추가했는데, api의 스펙이 변해버리는 문제

- setter를 제거하는 것이 좋은 설계
    - set을 막 가져다 쓰게 되면, 값이 어디서 변하는지 추적하기 어려움
    - 의미 있는 메서드(change 등)을 생성하여 데이터를 변경하면 메서드 이름으로 변경점을 찾기 쉬움
    - 엔티티 레벨에서 보고 추적 가능하도록 setter를 사용하지 않고 설계

- 코드 작성 시 유의할 점
    - Controller 에서 엔티티를 생성하지 말자.
    - Form 객체 전체를 Service로 넘기지 말고 필요한 데이터만 넘기자.
    - 필요한 데이터가 많은 경우 Service 계층에 DTO를 생성하자.
    - 식별자(ID)만 파라미터로 넘겨서 핵심 비즈니스 로직 (트랜잭션) 안에서 JPA가 동작하도록
    - 컨트롤러에서 엔티티를 찾아 넘기지 말고 서비스 트랜잭션 안에서 엔티티를 찾자.
    - 트랜잭션 안에서 엔티티를 조회해야 영속상태로 진행되는 등의 이점이 있음
    - 핵심 비즈니스 로직을 트랜잭션 안에서
